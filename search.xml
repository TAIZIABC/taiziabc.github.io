<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>HTML5 进阶系列：拖放 API 实现拖放排序</title>
      <link href="/2018/04/10/HTML5%20%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%8B%96%E6%94%BE%20API%20%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%94%BE%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/04/10/HTML5%20%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%8B%96%E6%94%BE%20API%20%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%94%BE%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>HTML5 中提供了直接拖放的 API，极大的方便我们实现拖放效果，不需要去写一大堆的 js，只需要通过监听元素的拖放事件就能实现各种拖放功能。<br><a id="more"></a><br>想要拖放某个元素，必须设置该元素的 draggable 属性为 true，当该属性为 false 时，将不允许拖放。而 img 元素和 a 元素都默认设置了 draggable 属性为 true，可直接拖放，如果不想拖放这两个元素，把属性设为 false 即可。</p><h3 id="拖放事件"><a href="#拖放事件" class="headerlink" title="拖放事件"></a>拖放事件</h3><p>拖放事件由不同的元素产生。一个元素被拖放，他可能会经过很多个元素上，最终到达想要放置的元素内。这里，我暂时把被拖放的元素称为源对象，被经过的元素称为过程对象，到达的元素我称为目标对象。不同的对象产生不同的拖放事件。</p><p>源对象：</p><pre><code>- dragstart：源对象开始拖放。- drag：源对象拖放过程中。- dragend：源对象拖放结束。</code></pre><p>过程对象：</p><pre><code>- dragenter：源对象开始进入过程对象范围内。- dragover：源对象在过程对象范围内移动。- dragleave：源对象离开过程对象的范围。</code></pre><p>目标对象：</p><pre><code>- drop：源对象被拖放到目标对象内。&lt;div id=&quot;source&quot; draggable=&quot;true&quot;&gt;a元素&lt;/div&gt;&lt;div id=&quot;process&quot;&gt;b元素&lt;/div&gt;&lt;div id=&quot;target&quot;&gt;c元素&lt;/div&gt;&lt;script&gt;    var source = document.getElementById(&apos;source&apos;),     // a元素        process = document.getElementById(&apos;process&apos;),   // b元素        target = document.getElementById(&apos;target&apos;);     // c元素    source.addEventListener(&apos;dragstart&apos;,function(ev){   // dragstart事件由a元素产生        console.log(&apos;a元素开始被拖动&apos;);    },false)    process.addEventListener(&apos;dragenter&apos;,function(ev){  // dragenter事件由b元素产生        console.log(&apos;a元素开始进入b元素&apos;);    },false)    process.addEventListener(&apos;dragleave&apos;,function(ev){  // dragleave事件由b元素产生        console.log(&apos;a元素离开b元素&apos;);    },false)    target.addEventListener(&apos;drop&apos;,function(ev){        // drop事件由c元素产生        console.log(&apos;a元素拖放到c元素了&apos;);        ev.preventDefault();    },false)    document.ondragover = function(e){e.preventDefault();}&lt;/script&gt;</code></pre><h3 id="dataTransfer-对象"><a href="#dataTransfer-对象" class="headerlink" title="dataTransfer 对象"></a>dataTransfer 对象</h3><p>在所有拖放事件中提供了一个数据传递对象 dataTransfer，用于在源对象和目标对象间传递数据。接下来认识一下这个对象的方法和属性，来了解它是如何传递数据的。</p><h4 id="setData"><a href="#setData" class="headerlink" title="setData()"></a>setData()</h4><p>该方法向 dataTransfer 对象中存入数据。接收两个参数，第一个表示要存入数据种类的字符串，现在支持有以下几种：</p><pre><code>- text/plain：文本文字。- text/html：HTML文字。- text/xml：XML文字。- text/uri-list：URL列表，每个URL为一行。</code></pre><p>第二个参数为要存入的数据。例如：</p><pre><code>event.dataTransfer.setData(&apos;text/plain&apos;,&apos;Hello World&apos;);</code></pre><h4 id="getData"><a href="#getData" class="headerlink" title="getData()"></a>getData()</h4><p>该方法从 dataTransfer 对象中读取数据。参数为在 setData 中指定的数据种类。例如：</p><pre><code>event.dataTransfer.getData(&apos;text/plain&apos;);</code></pre><h4 id="clearData"><a href="#clearData" class="headerlink" title="clearData()"></a>clearData()</h4><p>该方法清除 dataTransfer 对象中存放的数据。参数可选，为数据种类。若参数为空，则清空所有种类的数据。例如：</p><pre><code>event.dataTransfer.clearData();</code></pre><h4 id="setDragImage"><a href="#setDragImage" class="headerlink" title="setDragImage()"></a>setDragImage()</h4><p>该方法通过用img元素来设置拖放图标。接收三个参数，第一个为图标元素，第二个为图标元素离鼠标指针的X轴位移量，第三个为图标元素离鼠标指针的Y轴位移量。例如：</p><pre><code>var source = document.getElementById(&apos;source&apos;),icon = document.createElement(&apos;img&apos;);icon.src = &apos;img.png&apos;;source.addEventListener(&apos;dragstart&apos;,function(ev){    ev.dataTransfer.setDragImage(icon,-10,-10)},false)</code></pre><h4 id="effectAllowed-和-dropEffect-属性"><a href="#effectAllowed-和-dropEffect-属性" class="headerlink" title="effectAllowed 和 dropEffect 属性"></a>effectAllowed 和 dropEffect 属性</h4><p>这两个属性结合起来设置拖放的视觉效果。</p><p>值得注意的是：IE 不支持 dataTransfer 对象。对，不管哪个 IE 版本都不支持。</p><h3 id="实现拖放排序"><a href="#实现拖放排序" class="headerlink" title="实现拖放排序"></a>实现拖放排序</h3><p>上面已经熟悉了拖放 API 的使用，我们来实现个简单的拖放排序，这也是在项目中比较常见的。先来理一下思路：</p><pre><code>- 在一个列表中，每个元素都可以被拖放，那首先要给每个元素设置 draggable 属性为 true。- 监听每个元素的 dragstart 事件，对源对象做样式处理来区分。- 监听每个元素的 dragenter 事件，当源对象进入到当前元素里，就把源对象添加到该元素之前。这样子后面的元素就会被源对象挤下去了，实现了排序的效果。- 但是会发现，源对象无法排到最后一个去，只能在倒数第二。这时就要监听 dragleave 事件，当过程对象是最后一个元素时，源对象离开了过程对象，这时就把源对象添加到最后去。</code></pre><p>主要代码如下：</p><pre><code>var source = document.querySelectorAll(&apos;.list&apos;),dragElement = null;for(var i = 0; i &lt; source.length; i++){    source[i].addEventListener(&apos;dragstart&apos;,function(ev){        dragElement = this;    },false);    source[i].addEventListener(&apos;dragenter&apos;, function(ev){        if(dragElement != this){            this.parentNode.insertBefore(dragElement,this);        }    }, false)    source[i].addEventListener(&apos;dragleave&apos;, function(ev){        if(dragElement != this){            if(this == this.parentNode.lastElementChild || this == this.parentNode.lastChild){                this.parentNode.appendChild(dragElement);            }        }    }, false)};document.ondragover = function(e){e.preventDefault();}document.ondrop = function(e){e.preventDefault();}</code></pre><h3 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h3><p>主要是在IE中的兼容不太好，不过至少在IE10中能兼容上面的拖动排序。</p><p>而且在我简单的试验中发现，就是在 IE 中元素不设置 height 的时候，不会触发 dragleave 事件。</p>]]></content>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML5 进阶系列：文件上传下载</title>
      <link href="/2018/04/10/HTML5%20%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
      <url>/2018/04/10/HTML5%20%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
      <content type="html"><![CDATA[<p>HTML5 中提供的文件API在前端中有着丰富的应用，上传、下载、读取内容等在日常的交互中很常见。而且在各个浏览器的兼容也比较好，包括移动端，除了 IE 只支持 IE10 以上的版本。想要更好地掌握好操作文件的功能，先要熟悉每个API。<br><a id="more"></a></p><h3 id="FileList-对象和-file-对象"><a href="#FileList-对象和-file-对象" class="headerlink" title="FileList 对象和 file 对象"></a>FileList 对象和 file 对象</h3><p>HTML 中的 input[type=”file”] 标签有个 multiple 属性，允许用户选择多个文件，FileList对象则就是表示用户选择的文件列表。这个列表中的每一个文件，就是一个 file 对象。</p><p>file 对象的属性：</p><ul><li>name : 文件名，不包含路径。</li><li>type : 文件类型。图片类型的文件都会以 image/ 开头，可以由此来限制只允许上传图片。</li><li>size : 文件大小。可以根据文件大小来进行其他操作。</li><li>lastModified : 文件最后修改的时间。</li></ul><pre><code>&lt;input type=&quot;file&quot; id=&quot;files&quot; multiple&gt;&lt;script&gt;var elem = document.getElementById(&apos;files&apos;);  elem.onchange = function (event) {      var files = event.target.files;      for (var i = 0; i &lt; files.length; i++) {          // 文件类型为 image 并且文件大小小于 200kb          if(files[i].type.indexOf(&apos;image/&apos;) !== -1 &amp;&amp; files[i].size &lt; 204800){              console.log(files[i].name);          }      }  }&lt;/script&gt;</code></pre><p>input 中有个 accept 属性，可以用来规定能够通过文件上传进行提交的文件类型。</p><p>accept=”image/*” 可以用来限制只允许上传图像格式。但是在 Webkit 浏览器下却出现了响应滞慢的问题，要等上好几秒才弹出文件选择框。</p><p>解决方法就是将 * 通配符改为指定的 MIME 类型。</p><pre><code>&lt;input type=&quot;file&quot; accept=&quot;image/gif,image/jpeg,image/jpg,image/png&quot;&gt;</code></pre><h3 id="Blob-对象"><a href="#Blob-对象" class="headerlink" title="Blob 对象"></a>Blob 对象</h3><p>Blob 对象相当于一个容器，可以用于存放二进制数据。它有两个属性，size 属性表示字节长度，type 属性表示 MIME 类型。</p><h3 id="创建Blob-对象"><a href="#创建Blob-对象" class="headerlink" title="创建Blob 对象"></a>创建Blob 对象</h3><pre><code>var blob = new Blob([&apos;hello&apos;], {type:&quot;text/plain&quot;});</code></pre><p>Blob 构造函数中的第一个参数是一个数组，可以存放 ArrayBuffer对象、ArrayBufferView 对象、Blob对象和字符串。</p><p>Blob 对象可以通过 slice() 方法来返回一个新的 Blob 对象。</p><pre><code>var newblob = blob.slice(0,5, {type:&quot;text/plain&quot;});</code></pre><p>slice() 方法使用三个参数，均为可选。第一个参数代表要从Blob对象中的二进制数据的起始位置开始复制，第二个参数代表复制的结束位置，第三个参数为 Blob 对象的 MIME 类型。</p><p>canvas.toBlob() 也可以创建 Blob 对象。toBlob() 使用三个参数，第一个为回调函数，第二个为图片类型，默认为 image/png，第三个为图片质量，值在0到1之间。</p><pre><code>var canvas = document.getElementById(&apos;canvas&apos;);canvas.toBlob(function(blob){ console.log(blob); }, &quot;image/jpeg&quot;, 0.5);</code></pre><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><p>Blod 对象可以通过 window.URL 对象生成一个网络地址，结合 a 标签的 download 属性来实现下载文件功能。</p><p>比如把 canvas 下载为一个图片文件。</p><pre><code>var canvas = document.getElementById(&apos;canvas&apos;);canvas.toBlob(function(blob){    // 使用 createObjectURL 生成地址，格式为 blob:null/fd95b806-db11-4f98-b2ce-5eb16b38ba36    var url = URL.createObjectURL(blob);    var a = document.createElement(&apos;a&apos;);    a.download = &apos;canvas&apos;;    a.href = url;    // 模拟a标签点击进行下载    a.click();    // 下载后告诉浏览器不再需要保持这个文件的引用了    URL.revokeObjectURL(url);});</code></pre><p>也可以将字符串保存为一个文本文件，方法类似。</p><h3 id="FileReader-对象"><a href="#FileReader-对象" class="headerlink" title="FileReader 对象"></a>FileReader 对象</h3><p>FileReader 对象主要用来把文件读入内存，并且读取文件中的数据。通过构造函数创建一个 FileReader 对象</p><pre><code>var reader = new FileReader();</code></pre><p>该对象有以下方法：</p><pre><code>- abort：中断读取操作。- readAsArrayBuffer：读取文件内容到ArrayBuffer对象中。- readAsBinaryString：将文件读取为二进制数据。- readAsDataURL：将文件读取为data: URL格式的字符串。- readAsText：将文件读取为文本。</code></pre><h3 id="上传图片预览"><a href="#上传图片预览" class="headerlink" title="上传图片预览"></a>上传图片预览</h3><p>在常见的应用就是在客户端上传图片之后通过 readAsDataURL() 来显示图片。</p><pre><code>&lt;input type=&quot;file&quot; id=&quot;files&quot; accept=&quot;image/jpeg,image/jpg,image/png&quot;&gt;&lt;img src=&quot;blank.gif&quot; id=&quot;preview&quot;&gt;&lt;script&gt;    var elem = document.getElementById(&apos;files&apos;),        img = document.getElementById(&apos;preview&apos;);    elem.onchange = function () {        var files = elem.files,            reader = new FileReader();        if(files &amp;&amp; files[0]){            reader.onload = function (ev) {                img.src = ev.target.result;            }            reader.readAsDataURL(files[0]);        }    }&lt;/script&gt;</code></pre><h3 id="数据备份与恢复"><a href="#数据备份与恢复" class="headerlink" title="数据备份与恢复"></a>数据备份与恢复</h3><p>FileReader 对象的 readAsText() 可以读取文件的文本，结合 Blob 对象下载文件的功能，那就可以实现将数据导出文件备份到本地，当数据要恢复时，通过 input 把备份文件上传，使用 readAsText() 读取文本，恢复数据。</p><p>代码跟上面功能类似，这里不重复，具体的应用可以参考：<a href="https://github.com/lin-xin/notepad" target="_blank" rel="noopener">notepad</a></p><h3 id="Base64-编码"><a href="#Base64-编码" class="headerlink" title="Base64 编码"></a>Base64 编码</h3><p>在 HTML5 中新增了 atob 和 btoa 方法来支持 Base64 编码。它们的命名也很简单，b to a 和 a to b，即代表着编码和解码。</p><pre><code>var a = &quot;https://lin-xin.github.io&quot;;var b = btoa(a);var c = atob(b);console.log(a);     // https://lin-xin.github.ioconsole.log(b);     // aHR0cHM6Ly9saW4teGluLmdpdGh1Yi5pbw==console.log(c);     // https://lin-xin.github.io</code></pre><p>btoa 方法对字符串 a 进行编码，不会改变 a 的值，返回一个编码后的值。<br>atob 方法对编码后的字符串进行解码。</p><p>但是参数中带中文，已经超出了8位ASCII编码的字符范围，浏览器就会报错。所以需要先对中文进行 encodeURIComponent 编码处理。</p><pre><code>var a = &quot;哈喽 世界&quot;;var b = btoa(encodeURIComponent(a));var c = decodeURIComponent(atob(b));console.log(b);     // JUU1JTkzJTg4JUU1JTk2JUJEJTIwJUU0JUI4JTk2JUU3JTk1JThDconsole.log(c);     // 哈喽 世界</code></pre>]]></content>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Express + Mongoose 基础使用</title>
      <link href="/2018/04/09/Express%20+%20Mongoose%20%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/04/09/Express%20+%20Mongoose%20%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>Express 是基于 Node.js 平台的 web 应用开发框架，在学习了 Node.js 的基础知识后，可以使用 Express 框架来搭建一个 web 应用，实现对数据库的增删查改。<br><a id="more"></a><br>数据库选择 MongoDB，它是一个基于分布式文件存储的开源数据库系统，Mongoose 是 MongoDB 的对象模型工具，可以在异步环境里工作。</p><p>接下来就使用 Express + Mongoose 来实现简单的增删查改，在实现的过程中来学习 Express 和 Mongoose 的基础知识。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>既然是基于 Node.js 的框架，那么肯定需要装 node.js，还有 MongoDB，网上有很多安装教程。然后使用 express-generator 来快速生成一个 Express 项目。那么先安装一下 express-generator</p><pre><code>npm install -g express-generator</code></pre><p>然后初始化一个名为 express-demo 的项目</p><pre><code>express express-demo</code></pre><p>目前 Express 已经发布到了 4.x 版本，接下来也是基于这个版本来实现的。</p><pre><code>cd express-demonpm installnpm start</code></pre><p>浏览器打开 <a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a> ，就可以看到已经可以访问了。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><pre><code>├─bin/      // 启动文件├─public/   // 资源文件├─routes/   // 路由├─views/    // 视图├─app.js└─package.json</code></pre><p>初始化的项目目录简单明了，接下来我们来看看 app.js 里是写了什么。</p><pre><code>// view engine setupapp.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;));app.set(&apos;view engine&apos;, &apos;jade&apos;);</code></pre><p>这是设置模板引擎，使用了 jade 模板引擎，views/ 目录下都是 .jade 格式文件，这种写法我并不熟悉，那么来改一下，改成 ejs 引擎，.html 格式的视图文件。（需要 npm 安装 ejs 模块）</p><pre><code>var ejs = require(&apos;ejs&apos;);// view engine setupapp.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;));app.engine(&apos;html&apos;, ejs.__express);app.set(&apos;view engine&apos;, &apos;html&apos;);</code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>以上准备都好了之后，我们就来看看如何实现用户信息的增删查改。这里我们先把视图和路由搭建起来，能访问页面之后再来实现数据库操作的功能。</p><h3 id="用户列表"><a href="#用户列表" class="headerlink" title="用户列表"></a>用户列表</h3><p>在 view/ 视图目录下创建以下文件： UserList.html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;用户列表页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;table&gt;        &lt;tr&gt;            &lt;th&gt;用户名&lt;/th&gt;            &lt;th&gt;邮箱&lt;/th&gt;            &lt;th&gt;操作&lt;/th&gt;        &lt;/tr&gt;        &lt;% for(var i in user){ %&gt;            &lt;tr&gt;                &lt;td&gt;&lt;%= user[i].username %&gt;&lt;/td&gt;                &lt;td&gt;&lt;%= user[i].email %&gt;&lt;/td&gt;                &lt;td&gt;                    &lt;div&gt;                        &lt;a href=&quot;/users/detail/&lt;%=user[i]._id%&gt;&quot;查看 &lt;/a&gt;                        &lt;a href=&quot;/users/edit/&lt;%= user[i]._id %&gt;&quot;&gt; 编辑 &lt;/a&gt;                        &lt;a href=&quot;#&quot; class=&quot;del&quot; data-id=&quot;&lt;%= user[i]._id %&gt;&quot;&gt; 删除 &lt;/a&gt;                    &lt;/div&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;% } %&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>&lt;% %&gt; 就是 ejs 模板引擎的语法，user 是在路由渲染页面的时候传过来的，它是如何传的，待会再看。<br>接下来实现上面视图对应的路由，项目中默认已经给我们生成了两个路由。在 routes/ 路由目录下已经有了两个路由文件：index.js 和 users.js。</p><p>app.js 中，已经帮我们设置好了这两个路由：</p><pre><code>var index = require(&apos;./routes/index&apos;);var users = require(&apos;./routes/users&apos;);app.use(&apos;/&apos;, index);app.use(&apos;/users&apos;, users);    </code></pre><p>只要浏览器访问 <a href="http://localhost:3000/users" target="_blank" rel="noopener">http://localhost:3000/users</a> ，就能访问到 users 对应的页面了。我们来看看路由里 users.js 是如何写的。</p><pre><code>var express = require(&apos;express&apos;);var router = express.Router();router.get(&apos;/&apos;, function(req, res, next) {  res.send(&apos;respond with a resource&apos;);});module.exports = router;</code></pre><p>express.Router 类创建模块化、可挂载的路由句柄。我们修改上面代码来创建用户列表的路由 users/list</p><pre><code>var express = require(&apos;express&apos;);var router = express.Router();router.get(&apos;/&apos;, function(req, res, next) {  res.send(&apos;respond with a resource&apos;);});router.get(&apos;/list&apos;, function(req, res, next) {  var list = [{_id: 1, username: &apos;linxin&apos;, email: &apos;123123@qq.com&apos;}];  res.render(&apos;UserList&apos;,{      user: list  })});module.exports = router;</code></pre><p>还记得在 UserList.html 视图中的 user 变量吗，这里用到了 res.render() 响应方法，功能就是渲染视图模板，第一个参数为视图文件名，第二个参数为对象，用于向模板中传递数据，user 就是在这里传过去的。更改完路由之后重启服务器，访问 <a href="http://localhost:3000/users/list" target="_blank" rel="noopener">http://localhost:3000/users/list</a> 就可以看到用户列表页面了。</p><p>但是这用户信息是写死的，要怎么从数据库中读取呢？</p><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>我们这里用到了 Mongoose，需要先安装 npm install mongoose -S 。安装之后在项目中引入并连接到数据库 userdb</p><pre><code>var mongoose = require(&apos;mongoose&apos;);mongoose.Promise = global.Promise;mongoose.connect(&apos;mongodb://localhost:27017/userdb&apos;, {useMongoClient: true});</code></pre><p>连接成功之后，定义一个 Schema，它一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力。</p><pre><code>var userSchema = new mongoose.Schema({username: String,email: String})</code></pre><p>这里的 userSchema 还不能对数据库进行操作，只是定义了数据模型属性 username, email 为字符串类型。需要将该 Schema 发布为 Model，Model 是由 Schema 发布生成的模型，具有抽象属性和行为的数据库操作对。</p><pre><code>var model = mongoose.model(&apos;user&apos;, userSchema);</code></pre><p>最后 model 就可以对数据库进行操作了，把上面的代码封装成 userModel.js 到根目录下新建一个 models/ 目录下面，用 module.exports = model; 将 model 暴露出来供其他文件使用。</p><p>在 user.js 路由文件里，我们来引入 userModel.js 进行数据库操作。</p><pre><code>var userModel = require(&apos;../models/userModel.js&apos;);router.get(&apos;/list&apos;, function(req, res, next) {  userModel.find(function(err, data){    if(err){ return console.log(err) }    res.render(&apos;UserList&apos;,{      user: data    })  })});</code></pre><p>这里使用 userModel.find() 查询到所有用户。但是现在数据库里还是空的，我们来新增一个添加用户页面向数据库里插入数据。</p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p>在 views/ 目录下新建 UserAdd.html 添加用户视图</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;用户编辑页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;/users/add&quot; method=&quot;post&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot;&gt;        &lt;input type=&quot;email&quot; name=&quot;email&quot; value=&quot;&quot;&gt;        &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在 user.js 路由文件里来添加对应视图的路由</p><pre><code>router.get(&apos;/add&apos;, function(req, res, next) {  res.render(&apos;UserAdd&apos;);});</code></pre><p>这是渲染视图页面的路由，我们需要添加一个 post 方法的路由，在点击提交按钮的时候，把数据存进数据库里。</p><pre><code>router.post(&apos;/add&apos;, function(req, res, next) {  var newUser = new userModel({    username: req.body.username,    email: req.body.email  })  newUser.save(function(err, data){    if(err){ return console.log(err) }    res.redirect(&apos;/users/list&apos;);  })});</code></pre><p>这里使用 new userModel() 创建了一个 Entity，它是由 Model 创建的实体，它的操作也会影响数据库。newUser 调用 save() 方法将数据保存到数据库中。然后 res.redirect() 将页面重定向到用户列表页面，这时就可以看到我们新增的用户显示在列表中了。接下来我们看看如何来编辑用户信息。</p><h3 id="编辑用户"><a href="#编辑用户" class="headerlink" title="编辑用户"></a>编辑用户</h3><p>依然是创建相应的用户编辑视图：UserEdit.html</p><pre><code>router.get(&apos;/edit/:id&apos;, function (req, res, next) {  var id = req.params.id;  userModel.findOne({_id: id}, function (err, data) {    res.render(&apos;UserEdit&apos;, {      user: data    })  })});router.post(&apos;/update&apos;, function (req, res, next) {  var id = req.body.id;  userModel.findById(id, function (err, data) {    if(err){ return console.log(err); }    data.username = req.body.username;    data.email = req.body.email;    data.save(function(err){      res.redirect(&apos;/users/list&apos;);    })  })});</code></pre><p>userModel.findOne() 会根据查询条件 {_id: id} 查询到对应的一条数据，那么同理，查看用户详情的实现也是如此，只是渲染你到另外一个模板而已，这里就不重复写了；userModel.findById() 查询到 data 对象，该对象也属于 Entity，有 save() 操作。req.body.username 就可以获取到我们修改后的 username，修改 data 对象之后调用 save() 方法保存到数据库中。接下来看看如何删除用户吧。</p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>在用户列表中，点击删除按钮，就把该用户从数据库中给删除了，不需要视图，那直接写路由吧。</p><pre><code>router.delete(&apos;/del&apos;, function (req, res) {  var id = req.query.id;  userModel.remove({_id: id}, function (err, data) {    if(err){ return console.log(err); }    res.json({code: 200, msg: &apos;删除成功&apos;});  })})</code></pre><p>点击按钮，发送删除的请求，那我们可以使用 ajax 来实现。在用户列表页面引入 jquery，方便我们操作。然后添加 ajax 请求</p><pre><code>$(&apos;.del&apos;).on(&apos;click&apos;,function(){var id = $(this).data(&apos;id&apos;);$.ajax({    url: &apos;/users/del?id=&apos;+id,    type: &apos;delete&apos;,    success: function (res) { console.log(res); }})})</code></pre><p>重启服务器，进入 users/list，点击删除按钮，如果看到控制台中已经打印了 {code: 200, msg: ‘删除成功’} ，表示已经成功删除了，这时我们刷新页面，看看列表中确实已经不存在该用户了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过对用户的增删查改，学习如何写路由已经如何操作数据库。我们来总结一下：<br>1，定义 Schema，由 Schema 发布 Model 来操作数据库。<br>2，Model 创建的实体 Entity，可以调用 save() 方法将数据保存到数据库中。<br>3，Model.find() 方法查询到该 Schema 下的所有数据，findOne() 根据条件查询数据，findById() 根据 id 查询数据。<br>4，Model.remove() 删除数据。</p>]]></content>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML5 桌面通知</title>
      <link href="/2018/04/09/HTML5%20%E6%A1%8C%E9%9D%A2%E9%80%9A%E7%9F%A5%EF%BC%9ANotification%20API/"/>
      <url>/2018/04/09/HTML5%20%E6%A1%8C%E9%9D%A2%E9%80%9A%E7%9F%A5%EF%BC%9ANotification%20API/</url>
      <content type="html"><![CDATA[<p>Notification API 是 HTML5 新增的桌面通知 API，用于向用户显示通知信息。<br><a id="more"></a><br>该通知是脱离浏览器的，即使用户没有停留在当前标签页，甚至最小化了浏览器，该通知信息也一样会置顶显示出来。</p><h3 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h3><p>想要向用户显示通知消息，需要获取用户权限，而相同的域名只需要获取一次权限。只有用户允许的权限下，Notification 才能起到作用，避免某些网站的广告滥用 Notification 或其它给用户造成影响。那么如何知道用户到底是允不允许的？</p><p>Notification.permission 该属性用于表明当前通知显示的授权状态，可能的值包括：</p><li>default ：不知道用户的选择，默认。</li><br><li>granted ：用户允许。。</li><br><li>denied ：用户拒绝。</li><pre><code>if(Notification.permission === &apos;granted&apos;){console.log(&apos;用户允许通知&apos;);}else if(Notification.permission === &apos;denied&apos;){console.log(&apos;用户拒绝通知&apos;);}else{console.log(&apos;用户还没选择，去向用户申请权限吧&apos;);}</code></pre><h3 id="请求权限"><a href="#请求权限" class="headerlink" title="请求权限"></a>请求权限</h3><p>当用户还没选择的时候，我们需要向用户去请求权限。Notification 对象提供了 requestPermission() 方法请求用户当前来源的权限以显示通知。</p><p>以前基于回调的语法已经弃用（当然在现在的浏览器中还是能用的），最新的规范已将此方法更新为基于 promise 的语法：</p><pre><code>Notification.requestPermission().then(function(permission) {if(permission === &apos;granted&apos;){    console.log(&apos;用户允许通知&apos;);}else if(permission === &apos;denied&apos;){    console.log(&apos;用户拒绝通知&apos;);} });</code></pre><h3 id="推送通知"><a href="#推送通知" class="headerlink" title="推送通知"></a>推送通知</h3><p>获取用户授权之后，就可以推送通知了。</p><pre><code>var notification = new Notification(title, options)</code></pre><p>参数如下：</p><ul><li>title：通知的标题</li><li>options：通知的设置选项（可选）。</li><li>body：通知的内容。</li><li>tag：代表通知的一个识别标签，相同tag时只会打开同一个通知窗口。</li><li>icon：要在通知中显示的图标的URL。    </li></ul><p>还有一些其他的参数，因为用不了或者没什么用这里就没必要说了。  </p><p>通知消息的效果图如下：通知消息的效果图如下：<br><img src="http://taizi-blog.oss-cn-hangzhou.aliyuncs.com/18-4-9/4991617.jpg" alt="enter image description here"></p><h3 id="关闭通知"><a href="#关闭通知" class="headerlink" title="关闭通知"></a>关闭通知</h3><p>从上面的参数可以看出，并没有一个参数用来配置显示时长的。我想要它 3s 后自动关闭的话，这时可以调用 close() 方法来关闭通知。</p><pre><code>var n = new Notification(&apos;状态更新提醒&apos;,{body: &apos;你的朋友圈有3条新状态，快去查看吧&apos;})setTimeout(function() {n.close();}, 3000);</code></pre><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Notification 接口的 onclick属性指定一个事件侦听器来接收 click 事件。当点击通知窗口时会触发相应事件，比如打开一个网址，引导用户回到自己的网站去。</p><pre><code>var n = new Notification(&apos;状态更新提醒&apos;,{body: &apos;你的朋友圈有3条新状态，快去查看吧&apos;,data: {    url: &apos;http://blog.gdfengshuo.com&apos;}})n.onclick = function(){window.open(n.data.url, &apos;_blank&apos;);      // 打开网址n.close();                              // 并且关闭通知}</code></pre><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>现在网站的消息提醒，大多数都是在消息中心显示个消息数量，然后发邮件告诉用户，这流程完全没有错。不过像我这种用户，觉得别人点个赞，收藏一下都要发个邮件提醒我，老是要去删邮件（强迫症），我是觉得挺烦的甚至关闭了邮件提醒。</p><p>当然这里并不是说要用 Notification，毕竟它和邮件的功能完全不一样。</p><p>我觉得比较适合的是新闻网站。用户浏览新闻时，可以推送给用户实时新闻。以腾讯体育为例，它就使用了 Notification API。在页面中引入了一个 notification2017_v0118.js，有兴趣可以看看别人是怎么成熟的使用的。</p><p>一进入页面，就获取授权，同时自己页面有个浮动框提示你允许授权。如果允许之后，就开始给你推送通知了。不过它在关闭标签卡的时候，通知也会被关闭，那是因为监听了页面 beforeunload 事件。</p><pre><code>function addOnBeforeUnload(e) {    FERD_NavNotice.notification.close();}if(window.attachEvent){    window.attachEvent(&apos;onbeforeunload&apos;, addOnBeforeUnload);}else {    window.addEventListener(&apos;beforeunload&apos;,     addOnBeforeUnload, false);}</code></pre><h3 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h3><p>说到兼容，自然是倒下一大片，而且各浏览器的表现也会有点差异。移动端的几乎全倒，PC端的还好大多都能支持，除了IE。所以使用前，需要先检查一下浏览器是否支持 Notification。</p>]]></content>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Second artical</title>
      <link href="/2018/03/23/hexo+git%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/03/23/hexo+git%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>最近刚好有空，于是就参照网上的各种教程，搭建了一个博客。现在把 Hexo + GitHub Pages 搭建博客的完整过程记录下来：<br><a id="more"></a><br>个人博客地址：<a href="https://taiziabc.github.io">https://taiziabc.github.io</a></p><p>大概流程：</p><p>搭建 Node.js 环境<br>搭建 Git 环境<br>GitHub 注册和配置<br>安装配置 Hexo<br>关联 Hexo 与 GitHub Pages<br>GitHub Pages 地址解析到个人域名<br>Hexo 的常用操作<br>结束语<br>搭建 Node.js 环境</p><p>为什么要搭建 Node.js 环境？ - 因为 Hexo 博客系统是基于 Node.js 编写的<br>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。</p><p>在 Node.js 官网：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> 下载安装包 v6.10.3 LTS</p><p>保持默认设置即可，一路Next，安装很快就结束了。</p><p>然后打开命令提示符，输入 node -v、npm -v，出现版本号则说明 Node.js 环境配置成功，第一步完成！！！</p><p>搭建 Git 环境</p><p>为什么要搭建 Git 环境？ - 因为需要把本地的网页和文章等提交到 GitHub 上。<br>Git 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p><p>在 Git 官网：<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a> 下载安装包 Git-2.13.0-64-bit.exe</p><p>桌面右键，打开 Git Bush Here，输入 git –version，出现版本号则说明 Git 环境配置成功，第二步完成！！！</p><p>GitHub 注册和配置</p><p>GitHub 是一个代码托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。</p><p>Github注册：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p><p>image<br>image<br>创建仓库：Repository name 使用自己的用户名，仓库名规则：</p><p>注意：yourname 必须是你的用户名。</p><p>1<br>yourname/yourname.github.io</p><p>访问 yourname.github.io，如果可以正常访问，那么 Github 的配置已经结束了。</p><p>到此搭建 Hexo 博客的相关环境配置已经完成，下面开始讲解 Hexo 的相关操作</p><p>安装配置 Hexo</p><p>Hexo 是一个快速、简洁且高效的博客框架，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>强烈建议你花20分钟区读一读 Hexo 的官方文档：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p><p>使用 npm 安装 Hexo：在命令行中输入</p><p>1<br>npm install hexo-cli -g<br>然后你将会看到下图，可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用。</p><p>查看Hexo的版本</p><p>1<br>hexo version</p><p>安装 Hexo 完成后，请执行下列命令来初始化 Hexo，用户名改成你的，Hexo 将会在指定文件夹中新建所需要的文件。</p><p>1<br>2<br>3<br>4<br>5<br>hexo init bxm0927.github.io<br>cd bxm0927.github.io<br>npm install<br>新建完成后，指定文件夹的目录如下：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>.<br>├── .deploy         #需要部署的文件<br>├── node_modules    #Hexo插件<br>├── public          #生成的静态网页文件<br>├── scaffolds       #模板<br>├── source          #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里<br>| ├── _drafts       #草稿<br>| └── _posts        #文章<br>├── themes          #主题<br>├── _config.yml     #全局配置文件<br>└── package.json    #npm 依赖等<br>运行本地 Hexo 服务</p><p>1<br>2<br>3<br>hexo server<br>或者<br>hexo s<br>您的网站会在 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 下启动。如果 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 能够正常访问，则说明 Hexo 本地博客已经搭建起来了，只是本地哦，别人看不到的。下面，我们要部署到Github。</p><p>注意1：执行hexo server提示找不到该指令</p><p>解决办法：在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下：</p><p>1<br>2<br>3<br>sudo npm install hexo-server<br>或者<br>npm install hexo -server –save<br>关联 Hexo 与 GitHub Pages</p><p>我们如何让本地git项目与远程的github建立联系呢？用 SSH keys</p><p>生成SSH keys</p><p>输入你自己的邮箱地址</p><p>1<br>ssh-keygen -t rsa -C “<a href="mailto:80583600@qq.com" target="_blank" rel="noopener">80583600@qq.com</a>“<br>在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入，我们按回车不设置密码。</p><p>添加 SSH Key 到 GitHub</p><p>打开 C:\Users\bxm09.ssh\id_rsa.pub，此文件里面内容为刚才生成的密钥，准确的复制这个文件的内容，粘贴到 <a href="https://github.com/settings/ssh" target="_blank" rel="noopener">https://github.com/settings/ssh</a> 的 new SSH key 中</p><p>测试</p><p>可以输入下面的命令，看看设置是否成功，<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>的部分不要修改：</p><p>1<br>ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a><br>如果是下面的反馈：</p><p>The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.<br>RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.<br>Are you sure you want to continue connecting (yes/no)?<br>不要紧张，输入yes就好，然后会看到：</p><p>1<br>Hi aierui! You’ve successfully authenticated, but GitHub does not provide shell access.<br>配置Git个人信息</p><p>现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。<br>Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的。</p><p>1<br>2<br>git config –global user.name “bxm0927”<br>git config –global user.email “<a href="mailto:80583600@qq.com" target="_blank" rel="noopener">80583600@qq.com</a>“<br>配置 Deployment</p><p>在_config.yml文件中，找到Deployment，然后按照如下修改，用户名改成你的：</p><p>需要注意的是：冒号后面记得空一格！</p><p>1<br>2<br>3<br>4<br>5<br>6</p><h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><h2 id="Docs-https-hexo-io-docs-deployment-html"><a href="#Docs-https-hexo-io-docs-deployment-html" class="headerlink" title="Docs: https://hexo.io/docs/deployment.html"></a>Docs: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">https://hexo.io/docs/deployment.html</a></h2><p>deploy:<br>  type: git<br>  repo: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:bxm0927/bxm0927.github.io.git<br>  branch: master<br>本地文件提交到 GitHub Pages</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>// 删除旧的 public 文件<br>hexo clean<br>// 生成新的 public 文件<br>hexo generate<br>或者<br>hexo g<br>// 开始部署<br>hexo deploye<br>或者<br>hexo d<br>在浏览器中输入 <a href="https://bxm0927.github.io" target="_blank" rel="noopener">https://bxm0927.github.io</a> （用户名改成你的）看到了 Hexo 与 GitHub Pages 已经成功关联了，哇哇哇哇哇哇，开心死你了，不要忘了回来给我点赞哟 ~</p><p>注意1：若上面操作失败，则需要提前安装一个扩展：</p><p>1<br>npm install hexo-deployer-git –save<br>注意2：如果在执行 hexo d 后,出现 error deployer not found:github 的错误（如下），则是因为没有设置好 public key 所致，重新详细设置即可。</p><p>Permission denied (publickey).<br>fatal: Could not read from remote repository.<br>Please make sure you have the correct access rights<br>and the repository exists.<br>注意3：怎么避免 .md 文件被解析？</p><p>Hexo原理就是hexo在执行hexo generate时会在本地先把博客生成的一套静态站点放到public文件夹中，在执行hexo deploy时将其复制到.deploy文件夹中。Github的版本库通常建议同时附上README.md说明文件，但是hexo默认情况下会把所有md文件解析成html文件，所以即使你在线生成了 README. md，它也会在你下一次部署时被删去。怎么解决呢？</p><p>在执行hexo deploy前把在本地写好的README.md文件复制到.deploy文件夹中，再去执行hexo deploy。</p><p>GitHub Pages 地址解析到个人域名</p><p>Github Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服 务，站点可以被免费托管在 Github 上，你可以选择使用 Github Pages 默 认提供的域名 github.io 或者自定义域名来发布站点。<br>看着博客的域名是二级域名，总有一种寄人篱下的感觉，为了让这个小窝看起来更加正式，我在阿里云上买了一个域名，打算将博客绑定自己的域名。</p><p>进行该绑定过程，其实就是一个重定向的过程。</p><p>在 GitHub 仓库的根目录下建立一个 CNAME 的文本文件(注意：没有扩展名)，文件里面只能输入一个你的域名，不能加http://</p><p>1<br><a href="http://www.lovebxm.com" target="_blank" rel="noopener">www.lovebxm.com</a><br>注意：CNAME 一定是在你 Github 项目的 master 根目录下</p><p>进入阿里云域名解析地址，添加解析：</p><p>记录类型选择CNAME<br>主机记录填www<br>解析线路选择默认<br>记录值填yourname.github.io<br>TTL值为10分钟<br>再添加一个解析，记录类型A<br>主机记录填www<br>解析线路选择默认<br>记录值填你GitHub 的ip地址（在cmd中ping：）<br>1<br>ping bxm0927.github.com</p><p>点击保存，等 1 分钟，访问下你自己的域名，一切就ok了。</p><p>域名绑定成功，域名解析成功，因此你在浏览中输入 <a href="http://www.lovebxm.com，或" target="_blank" rel="noopener">www.lovebxm.com，或</a> lovebxm.com 就可以访问到博客了，输入 bxm0927.github.io 会重定向到 <a href="http://www.lovebxm.com。过程：www" target="_blank" rel="noopener">www.lovebxm.com。过程：www</a> 的方式，会先解析成 <a href="http://xxxx.github.io，然后根据" target="_blank" rel="noopener">http://xxxx.github.io，然后根据</a> CNAME 再变成 www</p><p>注意：CNAME文件在下次 hexo deploy的时候就消失了，需要重新创建，这样就很繁琐</p><p>方法一：每次 hexo d 之后，就去 GitHub 仓库根目录新建 CNAME文件</p><p>方法二：在 hexo g 之后， hexo d 之前，把CNAME文件复制到 “\public\” 目录下面，里面写入你要绑定的域名。</p><p>方法三（推荐）：将需要上传至github的内容放在source文件夹，例如CNAME、favicon.ico、images等，这样在 hexo d 之后就不会被删除了。</p><p>方法四：通过安装插件实现永久保留</p><p>1<br>$ npm install hexo-generator-cname –save<br>之后在_config.yml中添加一条</p><p>1<br>2<br>plugins:</p><ul><li>hexo-generator-cname<br>需要注意的是：如果是在github上建立的CNAME文件，需要先clone到本地，然后安装插件，在deploy上去即可。CNAME只允许一个域名地址。</li></ul><p>注意1：每次生成的 CNAME 都是 yoursite.com 怎么解决？</p><p>修改 _config.yml</p><p>1<br>2<br>3<br>4<br>url: <a href="http://www.lovebxm.com" target="_blank" rel="noopener">http://www.lovebxm.com</a><br>root: /<br>permalink: :year/:month/:day/:title/<br>permalink_defaults:<br>Hexo 的常用操作</p><p>发表一篇文章</p><p>1<br>2<br>3<br>4<br>hexo new “文章标题”<br>D:\GitHub\Hexo\test&gt;hexo new “文章标题”<br>INFO  Created: D:\GitHub\Hexo\test\source_posts\文章标题.md<br>在本地博客文件夹 source_posts 文件夹下看到我们新建的 markdown 文件。</p><p>当然，我们也可以手动添加Markdown文件在source-&gt;_deploy文件夹下，其效果同样可以媲美hexo new</p><p>文章编辑好之后，运行生成、部署命令：</p><p>1<br>2<br>3<br>4<br>5<br>hexo clean<br>hexo g<br>hexo d<br>当然你也可以执行下面的命令，相当于上面两条命令的效果</p><p>1<br>2<br>3<br>hexo clean<br>hexo d -g<br>新建一个自定义页面</p><p>1<br>hexo new page folder</p><p>###文章如何添加多个标签</p><p>有两种多标签格式</p><p>1<br>2<br>3<br>4<br>5<br>6<br>tags: [a, b, c]<br>或<br>tags:</p><ul><li>a</li><li>b</li><li>c<br>显示部分文章内容</li></ul><p>如果在博客文章列表中，不想全文显示，可以增加 <!-- more -->, 后面的内容就不会显示在列表。</p><p>1<br><!--more--><br>更改主题</p><p>官方主题库：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p><p>Hexo主题非常，推荐使用 Next 为主题，请阅读 Next 的官方文档（ <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a> ），5 分钟快速安装。</p><p>再提示一点，大家可以hexo主题修改一步就hexo s看下变化，初次接触对参数不清楚。只有hexo s后在可以在本地浏览到效果，Ctrl+C 停止服务器。</p><p>添加插件</p><p>添加 sitemap 和 feed 插件</p><p>切换到你本地的 hexo 目 CIA ，在命令行窗口，输入以下命令</p><p>1<br>2<br>npm install hexo-generator-feed -save<br>npm install hexo-generator-sitemap -save<br>修改 _config.yml，增加以下内容</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12</p><h1 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h1><p>Plugins:</p><ul><li>hexo-generator-feed</li><li>hexo-generator-sitemap<br>#Feed Atom<br>feed:<br>type: atom<br>path: atom.xml<br>limit: 20<br>#sitemap<br>sitemap:<br>path: sitemap.xml<br>再执行以下命令，部署服务端</li></ul><p>1<br>hexo d -g<br>配完之后，就可以访问 <a href="https://bxm0927.github.io/atom.xml" target="_blank" rel="noopener">https://bxm0927.github.io/atom.xml</a> 和 <a href="https://bxm0927.github.io/sitemap.xml" target="_blank" rel="noopener">https://bxm0927.github.io/sitemap.xml</a> ，发现这两个文件已经成功生成了。</p><p>添加 404 页面</p><p>GitHub Pages 自定义404页面非常容易，直接在根目录下创建自己的404.html就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。</p><p>其实，404页面可以做更多有意义的事，来做个404公益项目吧。</p><p>多PC同步管理博客</p><p>很多人可能家里一台笔记本，公司一个台式机，想两个同时管理博客，同时达到备份的博客主题、文章、配置的目的。下面就介绍一下用github来备份博客并同步博客。</p><p>A电脑备份博客内容到github<br>配置.gitignore文件。进入博客目录文件夹下，找到此文件，用sublime text 打开，在最后增加两行内容/.deploy_git和/public</p><p>初始化仓库。<br>在博客根目录下，在git bash下依次执行git init和git remote add origin 为远程仓库地址。</p><p>同步到远程仓库。<br>gitbash下依次执行以下命令</p><p>1<br>2<br>3<br>4<br>5<br>git add . #添加目录下所有文件<br>git commit -m “更新说明” #提交并添加更新说明<br>git push -u origin master #推送更新到远程仓库<br>B电脑拉下远程仓库文件<br>在B电脑上同样先安装好node、git、ssh、hexo，然后建好hexo文件夹，安装好插件，（然后选做：将备份到远程仓库的文件及文件夹删除），然后执行以下命令：</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>git init<br>git remote add origin <server><br>git fetch –all<br>git reset –hard origin/master<br>发布博客后同步<br>在B电脑发布完博客之后，记得将博客备份同步到远程仓库<br>执行以下命令：</server></p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>git add .</p><p>#可以用git master 查看更改内容<br>git commit -m “更新信息”<br>git push -u origin master  #以后每次提交可以直接git push<br>平时同步管理<br>每次想写博客时，先执行：git pull进行同步更新。发布完文章后同样按照上面的 发布博客后同步 同步到远程仓库。</p><p>中文乱码</p><p>在 md 文件中写中文内容，发布出来后为乱码，原因是 md 的编码不对，将 md 文件另存为UTF-8编码的文件即可解决问题。</p><p>结束语</p><p>建站的系统有很多，如：</p><p>Hexo + GitHub Pages<br>Jekyll + GitHub Pages<br>WordPress + 服务器 + 域名<br>DeDeCMS + 服务器 + 域名<br>…<br>使用 Hexo + GitHub Pages 建站，有优点也有缺点：</p><p>GitHub Pages 不支持数据库管理，所以你只能做静态页面的博客，不能像其他博客（如 WordPress）那样通过数据库管理自己的博客内容。<br>但是，GitHub Pages 无需购置服务器，免服务器费的同时还能做负载均衡，github pages有300M免费空间。<br>个人博客真的有必要用数据库吗？答案是否定的。博客静态化，评论记录使用第三方的 网易云跟帖就可以了。静态的博客更有利于搜索引擎蜘蛛爬取，轻量化的感觉真的很好。<br>通过 Hexo 你可以轻松地使用 Markdown 编写文章，非常符合我的口味。Markdown 真的是专门针对程序员开发的语言啊，现在感觉没有 Markdown什么都不想写。什么富文本编辑器，什么word，太麻烦了！而且样式都好丑！效率太低！<br>推荐几个很好用的在线 Markdown 编辑器：</p><p>作业部落：<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">https://www.zybuluo.com/mdeditor</a><br>马克飞象：<a href="https://maxiang.io" target="_blank" rel="noopener">https://maxiang.io</a><br>推荐图床：</p><p>极简图床 + chrome 插件 + 七牛空间，七牛云储存提供10G的免费空间,以及每月10G的流量，存放个人博客外链图片最好不过了，七牛云储存还有各种图形处理功能、缩略图、视频存放速度也给力。<br>最后更新时间：2017-06-01 09:45:48 </p>]]></content>
      
      <categories>
          
          <category> thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/03/22/hello-world/"/>
      <url>/2018/03/22/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      <categories>
          
          <category> thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>404</title>
      <link href="/404/index.html"/>
      <url>/404/index.html</url>
      <content type="html"><![CDATA[<p>404  页面。。。。。。。。</p>]]></content>
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<h2 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h2><p><strong>姓名：</strong>刘遂江</p><p><strong>专业：</strong>网络工程</p><p><strong>邮箱：</strong><a href="mailto:15297971325@163.com" target="_blank" rel="noopener">15297971325@163.com</a></p><p><strong>扣扣：</strong>1940775130</p><p><strong>github:  </strong><a href="https://github.com/TAIZIABC" target="_blank" rel="noopener">https://github.com/TAIZIABC</a></p><p><strong>个人简介：</strong>👉 专注 Web前端 + Node.js 的探索者，目前是一个大三学生，爱钻研，爱分享</p><blockquote><p>【前端】：HTML (Pug/Jade、ejs)、CSS (SASS/SCSS、Stylus)、JS (ES5/ES6)、Ajax、jQuery、Bootstrap，Angular2</p><p>【后端】：Node.js (Express)、PHP</p><p>【数据库】：MongoDB (mongoose)、MySQL、SQL Server</p></blockquote>]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
